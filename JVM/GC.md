## 가비지 컬렉션 (GC)

- stop-the-world: GC을 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것, GC를 실행하는 스레드를 제외한 나머지 스레드들은 모두 중지되므로 애플리케이션 성능에 지대한 영향을 끼침 → 이 stop-the-world 시간을 줄이는 것이 GC 튜닝의 핵심

### 객체 생사 판단 알고리즘

1. 참조 카운팅 알고리즘: 객체를 가리키는 참조 카운터를 추가하여 참조하는 곳이 하나 늘어날 때 마다 카운터를 1 증가, 사라지면 1 감소, 카운터가 0이 되면 죽은 것으로 판단

> 순환 참조의 문제: 서로를 참조하는 경우 외부에선 접근할 수 없어도 서로의 참조 때문에 카운터가 0이 아니므로 이를 회수할 수 없다
> 
1. 도달 가능성 분석 알고리즘: 자바에서 사용, 루트 객체들을 시작 노드 집합으로 사용하고 루트로부터 도달 불가능한 객체는 죽은 객체로 판단

<img src="https://velog.velcdn.com/images/cksgodl/post/a223e3d6-df10-4e65-b4c2-4ccd3c8f5487/image.png">

출처: [[JVM 밑바닥까지 파헤치기] 3장 - 가비지 컬렉터와 메모리 할당 전략](https://velog.io/@cksgodl/JVM-%EB%B0%91%EB%B0%94%EB%8B%A5%EA%B9%8C%EC%A7%80-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0-3%EC%9E%A5-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%ED%84%B0%EC%99%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9-%EC%A0%84%EB%9E%B5)

GC Root: **GC가 객체 그래프 탐색을 시작할 때, 절대 삭제하면 안 되는 기본 출발점 노드
GC Root에 포함되는 객체들은 주로 아래와 같은 곳에 위치**

- 메서드 호출 스택 안에 있는 지역 변수(실행 컨텍스트)
- 전역 참조(클래스 static 필드, 상수(final) 등)

> **항상 유효해야 하고** (삭제하면 안 되고), 명확한 생명 주기를 가져야 하기 때문
> 

### 참조의 종류

메모리가 여유롭다면 그냥 두고, GC 후에도 메모리가 매우 부족하다면 그때 회수하는 ‘버리기는 아까운’ 객체를 표현하기 위해 4가지 종류로 구분

- 강한 참조(strong reference): 프로그램 코드에서 참조를 할당, 강한 참조 관계가 남아있는 객체는 가비지 컬렉터가 절대 회수하지 않음
- 부드러운 참조(sotf reference): 유용하지만 필수는 아닌 객체, 일단 냅두다가 메모리 오버플로우 (OutOfMemoryError)
발생 직전에 회수

> 주로 캐시 구현에 사용 (ex. 한 번 로드한 이미지를 소프트 참조로 캐시에 저장하면, 메모리가 충분할 때는 해당 이미지를 재사용하고, 메모리가 부족해지면 GC가 이를 회수하여 메모리를 확보)
> 
- 약한 참조(weak reference): 부드러운 참조와 비슷하지만 연결 강도가 더 약함. 다음번 GC 전까지만 생존
- 유령 참조(phantom reference): 대상 객체가 회수될 때 알림을 받기 위해서 존재하는 참조로, 객체 수명에 아무런 영향을 주지 않으며, 유령 참조를 통해 객체 인스턴스를 가져오는 것마저 불가능

### 메소드 영역의 회수

young 영역은 일반적으로 GC 한번으로 메모리 공간의 70~99%를 회수하는 반면, 메소드 영역의 GC의 경우 회수 조건이 까다로워서 힙 영역의 GC보다 효율이 훨씬 떨어짐

### 세대 단위 컬렉션 이론

**GC의 가설(전제 조건)**

- 대부분의 객체는 **금방 접근 불가능 상태(unreachable)**가 된다. (약한 세대 가설)
- GC 과정에서 살아남은 횟수가 늘어날수록 더 오래 생존할 가능성이 커진다. (강한 세대 가설)
- 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다. (세대 간 참조 가설)

> 대다수의 객체가 곧바로 죽을 운명이라면, 그 객체들을 한데 몰아놓고 살아남을 소수의 객체를 유지하는 데 집중하는 편이 유리하다. 이를 반영하기 위해 HotSpot VM에서는 Young 영역과 Old 영역 크게 2개로 물리적 공간을 나누었다.
> 

- Young 영역(Yong Generation 영역): 새롭게 생성한 객체의 대부분이 여기에 위치한다. **대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 매우 많은 객체가 Young 영역에 생성되었다가 사라진다.** 이 영역에서 객체가 사라질때 **Minor GC**가 발생한다고 말한다.
- Old 영역(Old Generation 영역): 접근 불가능 상태로 되지 않아 Young 영역에서 **살아남은 객체**가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, **크기가 큰 만큼 Young 영역보다 GC는 적게 발생**한다. 이 영역에서 객체가 사라질 때 **Major GC(혹은 Full GC)**가 발생한다고 말한다.

> 한 번 살아남은 객체는 통계적으로 잘 죽지 않으니 별도의 영역에 따로 모아두고, 이 영역의 GC 횟수를 줄이는 방식으로 최적화
> 
- 기억 집합이란?
    
    신세대에서만 마이너GC를 하고 싶어도 구세대에서 참조 중인 객체가 있을 수 있다. 이는 고정된 GC루트뿐만 아니라 구세대 객체까지 모두 탐색해야 결과를 신뢰할 수 있다.
    
    하지만 이는 낭비가 심하기에 신세대에 기억 집합이라는 전역 데이터 구조를 하나 두어 “**다른 세대(Generation) 객체가 나를 참조하고 있다” 는 정보를 기록**
    
- Stop-The-World 란?
    
    GC를 위해 JVM이 GC를 실행하는 스레드를 제외한 모든 스레드 실행을 멈추는 것 
    Full GC의 경우 수 초 이상 지속될 수 있고 이로 인한 DB 커넥션이 끊기는 등 장애 상황이 발생할 수 있음
    

개발자의 관점에선 Old Generation 영역까지 살아남는 객체들이 어떤게 있을 지 생각해보고, 최대한 이러한 객체들을 만들지 않아서 Full GC가 발생되지 않도록 해야 함

> JVM은 실행 중에 Young/Old 세대 크기를 자동으로 조정하는데, 자주 GC되지 않는 Old 영역에 객체들이 많이 쌓여서 커지게 되면 힙 영역의 메모리가 소진될 수 있으므로 주의해야 하고 이런 현상이 발생하면 heap dump를 통해 분석해야 함
> 

### Young 영역

- Eden 영역
    
    새로운 객체들이 최초로 할당되는 공간
    
    한번의 Minor GC로부터 살아남으면 Survivor 영역으로 **이동**
    
- Survivor 영역 2개
    
    Minor GC가 발생할 때 마다 survivor 1, survivor 2 영역을 번갈아가며 이동
    
    GC 사이클을 거칠 때 마다 연령이 증가하는데, 일정 연령에 도달하면 Old Generation으로 승격
    

## 가비지 컬렉션 알고리즘

### Mark-Sweep

표시(Mark)와 쓸기(Sweep) 두 단계로 나눠 진행

먼저 회수할 객체들을 모두 표시하고, 표시된 객체들을 쓸어 담는 방식

- 단점
1. 실행 효율이 일정하지 않음

> 객체가 많아질 수록 표시하고 쓸어담는 일이 커져 작업의 효율이 떨어지는 구조
> 

2. 메모리 파편화가 심함

> 쓸고 간 자리에 불연속적인 메모리 파편이 발생하는데 이로 인해 큰 객체를 할당하려 할 때 충분한 크기의 연속된 메모리를 찾는게 점점 어려워지고, 이는 또 다른 GC를 유발
> 

### Mark-Copy

Mark-Sweep의 메모리 파편화 문제를 해결하기 위해 등장

가용 메모리를 똑같은 크기의 두 블록으로 나누어 한번에 한 블록만 사용하고, 블록이 꽉 차면 **살아남은 객체들만 다른 블록에 복사하고 기존 블록을 한번에 청소**

> 대다수의 객체는 금방 접근 불가능 상태가 되므로 생존한 소수의 객체만 복사하면 되고, 복사 과정에서 객체들이 메모리의 한쪽 끝에서부터 차곡차곡 쌓이기 때문에 메모리 파편화 문제 예방
> 
- 단점: 가용 메모리를 절반으로 줄이기 때문에 낭비가 심함

> IBM 연구 결과 young 객체 중 98%가 첫번째 GC에서 살아남지 못함 → 이러한 결과를 바탕으로 복사 영역을 전체 메모리의 절반으로 둘 필요가 없다고 결론짓고 young 영역을 하나의 큰 eden 영역과 두 개의 작은 survivor 영역으로 나눔    
메모리를 할당 할 때 에덴과 생존자 영역 중 하나만 사용하고, GC가 시작되면 여기서 살아남은 객체들을 나머지 하나의 생존자 영역으로 하나씩 복사    
에덴과 생존자 영역 공간 비율이 8:1이므로 young 영역 중 90%를 메모리 할당에 활용하여 낭비되는 메모리 공간을 10%로 줄임    
만약 생존 객체가 10%가 넘으면 메모리 할당 보증 매커니즘으로 old 영역을 활용    
> 

### Mark-Comapct

표시 단계는 Mark-Sweep과 동일하지만, 차이점은 다음 컴팩트 단계에서 회수 대상들을 곧바로 쓸어담는 대신 생존한 모든 객체를 

메모리 영역의 한쪽 끝으로 모은 다음(이동), 나머지 공간을 한꺼번에 비움

> Old 영역에서 사용
생존한 객체들을 이동시킨 후, 이를 가리키던 참조들을 모두 갱신시키는 작업의 비용과 메모리 파편화의 트레이드오프    
메모리 파편화를 감내하면서 Mark-Sweep을 사용하다가, 객체 할당에 영향을 줄 만큼 파편화가 심해지면 Mark-Compact 로 돌려 연속된 공간을 확보     
> 

<img src="https://camo.githubusercontent.com/bb8c9fa296566d69d610f47b1baae8127f439f9643a212f444b3f75884f1c64d/68747470733a2f2f626c6f672e6b616b616f63646e2e6e65742f646e2f6247676842572f627472767644674948524f2f48786f58337739736b676168337846566866456744302f696d672e706e67">

## 클래식 가비지 컬렉터



### 시리얼 컬렉터



GC가 단일 스레드에서 동작, GC가 시작되면 회수가 완료될 때까지 다른 모든 작업 스레드는 멈춰 있어야 함

### 파뉴 컬렉터



시리얼 컬렉터를 병렬화, 멀티스레드를 이용한다는 점만 제외하면 시리얼 컬렉터와 동일

GC 스레드는 기본적으로 프로세서의 코어 수와 동일하게 설정

### CMS 컬렉터



GC에 따른 스레드 일시 정지 시간을 최소화하기 위해 등장

1. 최초 표시: GC 루트와 직접 연결된 객체들만 표시하기 때문에 매우 빠르게 종료
2. 동시 표시: GC 루트와 직접 연결된 객체들로부터 시작해 객체 그래프 전체를 탐색한다. 시간이 오래 걸리지만 사용자 스레드를 멈추지는 않는다. GC 스레드와 동시에 실행된다는 뜻이다.
3. 재표시: 동시 표시 도중 사용자 스레드가 참조 관계를 변경한 객체들을 바로잡는다
4. 동시 쓸기: 표시되어 있는 죽은 객체를 정리하는 단계다.

> Mark, Remark 단계는 여전히 stop the world 방식이지만, **가장 긴 부분인 동시 표시와 동시 쓸기 단계가 사용자 스레드를 멈추지 않는 것**이 중요
> 

단점

- 동시 수행 단계에서 사용자 스레드를 멈추지는 않더라도 애플리케이션을 느리게 하고 전체 처리량을 떨어뜨리는 건 피할 수없다.
- CMS의 동시 표시와 동시 쓸기 단계 동안 사용자 스레드는 여전히 실행 중이기 때문에 표시 스레드가 지나간 후에 쓰레기가 된 객체는 쓸기 단계에서 회수할 수 없다.
- 컴팩트 과정이 없기 때문에 메모리 파편화가 일어난다

### G1 컬렉터

<img src="https://camo.githubusercontent.com/c6945d273831479c778c0eb73aba27b34443a8560b316a9e011ac07b1967719a/68747470733a2f2f77777a2d66726f6e74656e642d61737365742e73332e61702d6e6f727468656173742d322e616d617a6f6e6177732e636f6d2f74656368626c6f672f73616e64626f782f615731685a3255253344253238372532392e706e67">

G1은 Garbage First를 짧게 줄인 표현

리전: 이전 GC들과 다르게 Heap 영역에 고정된 메모리 크기로 각 Generation을 구분하지 않고, 힙 영역을 동일한 크기의 Region으로 나누어 관리

> 힙 메모리의 어느 곳이던 회수 대상에 포함될 수 있음
어느 세대에 속하느냐가 아닌 “어느 영역에 쓰레기가 가장 많으냐”, “회수했을 때 가장 큰 이득인 영역이 어디냐”가 회수 영역을 고르는 기준이 됨
> 

우선순위 목록을 관리하며 사용자가 `-XX:MaxGCPause` Millis 매개 변수로 설정한 일시 정지 시간(기본값은 200밀리초)이 허용하는 한도내에서 회수 효과가 가장 큰 리전부터 회수 (정지 시간 예측 모델)

자바 힙 전체를 한 번에 청소하는 대신, 애플리케이션의 메모리 할당 속도(할당률)에 맞춰 회수하는 방향으로 변화

객체가 버려지는 속도를 컬렉터가 따라갈 수만 있다면 모든 것이 완벽하게 동작하는 모델

자바 9부터 21까지 기본 가비지 컬렉터였으나, 이후에는 ZGC가 점점 메인스트림으로 채택중이다

## 참고

JVM 밑바닥까지 파헤치기   
https://www.youtube.com/watch?v=GU254H0N93Y   
https://github.com/rlaope/estudy/blob/master/Back-End/JAVA/g1gc.md
