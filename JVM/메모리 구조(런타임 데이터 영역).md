## JVM의 메모리 구조 (런타임 데이터 영역)

<img width="401" alt="스크린샷 2025-04-04 오후 9 37 50" src="https://github.com/user-attachments/assets/2a5ea28e-c6b0-4462-82e3-7054c7f653ed" />


- PC 레지스터
- 가상 머신 스택: 메소드가 호출될 때마다 스택에 프레임을 push

> 프레임에는 상수 풀 참조, 지역 변수 배열, operand stack
> 
- 네이티브 메소드 스택: 가상 머신 스택이 자바 메소드(바이트코드)를 실행할 때 사용된다면, 네이티브 메소드 스택은 네이티브 메소드(하드웨어 플랫폼에 종속적인(어셈블리?))를 실행할 때 사용
- 힙
- 메소드 영역: 클래스 구조, 메서드 코드, 런타임 상수 풀 등 **클래스와 관련된 메타데이터**를 저장

> 자바 8 이전에는 메소드 영역을 구현하는 방식으로 **영구 세대**를 사용하여 **힙 메모리의 일부**로서 클래스 메타데이터, 상수, 정적 변수 등을 저장   
그러나 이는 고정된 최대 크기로 인해 OOM이 빈번하게 발생하는 문제가 있었음, 이를 해결하기 위해 자바 8부터는 이를 **메타스페이스** 라는 **네이티브 메모리 영역에** 저장하여 힙 메모리의 부담을 줄이고, 가비지 컬렉션의 효율성을 향상   
(영구 세대와 달리 메모리가 동적으로 관리되며 필요할 경우 OS에게 요청하여 메모리를 추가 할당 가능)

**즉, 메소드 영역이라는 것은 개념인거고 이를 어디에 구현할 지가 자바 8 이전에는 자바 힙 내부의 영구 세대, 이후에는 네이티브 메모리 내부의 메타스페이스 로 옮겨진 것**
> 

- 네이티브 메모리 영역이란?
    
    OS가 직접 할당해준 메모리 영역으로 GC 대상 X, **사이즈가 크고 오래 살아남는 객체**들을 힙에서 네이티브 메모리 영역으로 옮겨주어 **Full GC 성능 저하를 줄일 수 있음**
    
    - **Thread Stack 메모리** (-Xss)
    - **JNI 네이티브 호출** 시 할당 메모리
    - **DirectByteBuffer** (NIO)
    - **Metaspace**
- String Constant Pool 이란?
    
    힙 영역의 특수한 공간으로, 동일한 문자열 리터럴을 재사용하여 메모리를 절약하기 위해 존재
    
    리터럴 방식으로 생성된 문자열(ex. `String a = "AAAA";`)은 String Constant Pool에 저장되며, 동일한 문자열이 이미 존재하면 새로운 객체를 생성하지 않고 기존 객체를 참조합니다. 반면, new 키워드를 사용하여 생성된 문자열은 항상 새로운 객체를 생성한다.
    
- 심볼릭 참조와 상수 풀 해석이란?
    
    심볼릭 참조: 컴파일된 클래스 파일의 **런타임 상수 풀(Runtime Constant Pool)** 에 저장된 간접 참조
    
    > 실제 메모리 주소가 아닌 이름, 서명, 디스크립터 같은 정보를 포함 (컴파일 시점에 다른 클래스나 멤버의 실제 주소를 알 수 없기 때문)
    > 
    
    상수 풀 해석: 심볼릭 참조를 **실제 메모리 주소**로 변환하는 과정
    
    > 심볼릭 참조된 클래스나 인터페이스가 아직 로드되지 않았다면, 클래스 로더에게 요청을 보내 메소드 영역에 로드
    JVM은 항상 메소드 영역에 저장된 클래스 정보를 확인하여 객체 할당에 필요한 메모리 크기를 결정
    >
