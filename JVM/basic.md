## 정의

자바 가상 머신으로, 운영체제와 자바 사이의 중개자 역할을 수행

## 사용하는 이유

자바의 **“Write Once, Run Anywhere”** 철학을 반영하기 위해

C나 C++ 같은 컴파일 언어는 하드웨어 아키텍처에 종속적인 기계어로 변환

> 하드웨어 아키텍처가 달라지면 (ex. x86 -> ARM) 이 변환한 기계어는 사용할 수 없고 다시 해당 하드웨어 아키텍처에 맞게 다시 컴파일을 해야한다
> 

자바는 모든 하드웨어 플랫폼에서 동작할 수 있도록 각 플랫폼에 맞게 구현된 JVM 미들웨어를 두고, 자바 언어는 JVM이 이해할 수 있는 바이트 코드로 변환

> 바이트 코드만 있으면 어떤 하드웨어 아키텍처와 OS이던 JVM 위에서 실행시킬 수 있다
> 

## JIT 컴파일

초창기 JVM은 이 바이트 코드를 한줄한줄 해석하여 실행시키는 인터프리터 방식으로 구현되었으나, 이 방식의 단점은 기계어로 변환하는 컴파일 언어보다 수행속도가 느리다는 점이었다. 따라서 이를 보완하고자 런타임에 기계어로 변환하는 JIT 컴파일을 도입

핫 코드 감지 기술을 통해 메소드가 자주 호출되거나 순환문같은 메소드 안에 시간을 많이 잡아먹는 요소(핫 코드)가 있다면 이를 런타임에 감지해 JIT 컴파일러에게 알려주어 네이티브 코드로 컴파일

> 인터프리터 언어의 장점인 즉시 실행 + 컴파일 언어의 장점인 빠른 실행
> 

## 구성 요소, 동작 방식

- Class Loader: 자바 애플리케이션에서 필요한 클래스 파일(.class)을 메모리에 로드하고, 이를 실행 전에 준비하는 역할을 수행

> 클래스 파일에 존재하는 데이터가 자바 **바이트 코드**
> 
- Execution Engine: 메모리에 로드된 바이트코드를 실제 기계어로 변환하여 실행하는 역할

> 인터프리터, JIT 컴파일러, 가비지 컬렉터로 구성
> 

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpjywN%2FbtqSduBXLIK%2F2QEL5c2nEJXRm0cyhvwxF1%2Fimg.png">

- .java 파일을 .class 파일(바이트코드)로 컴파일
- Class Loader는 .class 파일의 클래스 정보(메타데이터)를 런타임 데이터 영역의 메소드 영역에 로드한다
- Execution Engine은 Runtime Data Area에 로딩된 .class 해석 및 실행 (이 과정에서 GC 작동과 스레드의 동기화 시작)

바이트 코드란?
    
  JVM이 이해할 수 있는 명령어 집합, 바이트 코드를 Execution Engine의 인터프리터로 기계어로 번역
    
